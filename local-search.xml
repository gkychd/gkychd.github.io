<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2026/02/15/hello-world/"/>
    <url>/2026/02/15/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Scaling Law</title>
    <link href="/2026/02/15/ai-infra/scaling-law/"/>
    <url>/2026/02/15/ai-infra/scaling-law/</url>
    
    <content type="html"><![CDATA[<p><a href="https://infrasys-ai.github.io/aiinfra-docs/00Summary/02StandardScaling.htm">https://infrasys-ai.github.io/aiinfra-docs/00Summary/02StandardScaling.htm</a></p><ol><li>概念：Scaling Law（尺度定律）是大模型领域的”第一性原理”。它描述了一种规律：神经网络的性能（误差）会随着模型参数量、训练数据量、以及总算力的增加，呈现出一种极其稳定的、幂律分布的提升。</li></ol>]]></content>
    
    
    <categories>
      
      <category>AI基础设施</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AI</tag>
      
      <tag>Scaling Law</tag>
      
      <tag>大模型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构与算法</title>
    <link href="/2026/02/15/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <url>/2026/02/15/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h2><h3 id="c-相关知识"><a href="#c-相关知识" class="headerlink" title="c++相关知识"></a>c++相关知识</h3><p>test4</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo 主题切换</title>
    <link href="/2026/02/15/blog/hexo-theme-switch/"/>
    <url>/2026/02/15/blog/hexo-theme-switch/</url>
    
    <content type="html"><![CDATA[<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">hexo config theme solitude<br>hexo config theme butterfly<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>主题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解计算机系统</title>
    <link href="/2026/02/15/cs-fundamentals/csapp/"/>
    <url>/2026/02/15/cs-fundamentals/csapp/</url>
    
    <content type="html"><![CDATA[<h2 id="深入理解计算机系统"><a href="#深入理解计算机系统" class="headerlink" title="深入理解计算机系统"></a>深入理解计算机系统</h2><h3 id="信息的表示和处理"><a href="#信息的表示和处理" class="headerlink" title="信息的表示和处理"></a>信息的表示和处理</h3><ol><li><p>大多数计算机采用小端存储，即低有效字节在前，二进制采用补码存储。</p></li><li><p>正数的反码和补码都是其本身，负数的反码符号位不变，其余位取反，补码则在反码的基础上加1，用补码便于正负数计算；计算机存储的都是补码，对用户来说还是正常原码输入，编译器会去转化为补码存储。</p></li><li><p>在补码表示中，最高位为符号位，其代表的值是负数，比如补码1111，计算为-2^3+2^2+2^1+1&#x3D;-1，这个数的原码是1001，原码的最高位仅仅表示符号，其原码解析也是-1。</p></li><li><p>有符号整型的最小值没有原码表示，只能用补码表示，比如int8的最小值-128，补码表示10000000，没有原码表示。</p></li><li><p>有符号数和无符号数之间的转换：位值不变，只是改变解释位的方式。</p></li><li><pre><code class="c++">int8_t a = -1;uint8_t b = a;//则b = -1 + 2^8 = 255，十六进制表示都是FF，二进制表示都是11111111，对于正数且不超过int8最大值的数来说，转换正常</code></pre></li><li><p>有符号数和无符号数之间的运算可能会出现意想不到的结果，且运算都是转换为无符号数进行，包括结果也是用无符号数去解析。</p></li><li><p>拓展数字：无符号数是0拓展，有符号数拓展的位数用最高位的数字填充（正数为0，负数为1）</p></li><li><p>从低位拓展成高位在数值上则不会出现问题，计算机默认拓展不会出现问题，但是如果手动去拓展，一定要注意有符号数还是无符号数。</p></li><li><p>从低位拓展成高位在数值上则不会出现问题，计算机默认拓展不会出现问题，但是如果手动去拓展，一定要注意有符号数还是无符号数。</p></li><li><p>在IEEE754标准中，float符号位1，阶码位8，尾数为23，尾数位决定了其表示整数的精度，只能精确表示-2^24～2^24的整数。</p></li><li><p>IEEE754标准中，非规格化数、规格化数、无穷大依次增大，即非规格化数在0附近，表示那些非常接近0的数。</p></li></ol><h3 id="程序的机器级表达"><a href="#程序的机器级表达" class="headerlink" title="程序的机器级表达"></a>程序的机器级表达</h3><h4 id="程序编码"><a href="#程序编码" class="headerlink" title="程序编码"></a>程序编码</h4><ol><li>程序抽象：有两种抽象，一是ISA指令集、二是虚拟地址</li><li>代码关系：C语言-&gt;汇编代码-&gt;机器级代码，相比于机器级代码的二进制格式，汇编代码更易读。</li><li>汇编代码和机器代码之间的关系几乎是一一对应的，就像查字典一样。并没有C语言那种数据类型、虚拟地址等抽象。</li><li>leaq：加载有效地址，也是特殊的算术运算。（%rdi）中括号表示取%rdi这个地址所指向区域的值，leaq S，D需要对S取地址，由于裸%rdi是寄存器，存在于cpu中，本身没有地址值，因此需要用（）包起来。用C语言类比，（）类似于*，leaq对于S的操作类似于&amp;。</li><li>栈地址是向下生长的，内存访问如数组是向上生长的，因此当缓冲区溢出时，会访问到高地址，从而破坏高地址处的数据，也可能是返回地址，”一头踩进上一个函数”。</li><li>在栈中申请的内存，必须在编译时或者函数进入时确定大小，因此std::vector这种动态扩容的结构的数据是在堆上的，不过std::vector本身这个管理其结构堆内存的数据是在栈上的，为24字节。</li><li>汇编代码本身随着行数的增加，地址增加，cpu内部有一个核心寄存器%rip，为指令指针，在执行完当前指令后，%rip会自动加上当前指令的长度，指向紧随其后的下一个地址。于此相反的是，栈增长，地址往小走。</li><li>跳转指令存储的是目标地址和当前地址的下一个地址的相对偏移量。</li><li>循环的两种方式jump-to-middle和guarded-do，基于o1编译的都是后者，效率更高，原因1：前者每次循环时必须执行一次无条件跳转；原因2：分支预测器喜欢简单的循环模式，后者循环里除了最后一次都是地址往回跳，预测概率更高，而jtm模式一半向前一半向后，误判损失高。</li><li>向栈传递参数为什么数据大小要8字节对齐？ 原因1：现代64位cpu的数据总线宽度是64位（8字节），cpu从内存读取数据时，一次读8个字节。因此如果数据起始地址是8个倍数，cpu只需要读一次就能把8个字节读进寄存器，否则数据会跨越两个8字节的边界，cpu要进行两次内存读取，还要进行复杂的移位和拼接，性能会下降。原因2：栈操作push、pop指令与栈指针%rsp紧密绑定，执行pushq时，固定将%rsp减去8。原因3：system  V ABI规定，栈上的每个参数必须占用一个完整的槽位slot，这个槽位的大小就是机器字长。</li><li>寄存器局部存储空间：用cpu中宝贵的几十个寄存器代替内存中的栈，加速局部变量的读写。需要注意在使用时，如果需要保留原数据，调用pushq保存到栈中，处理完后再popq出来。</li><li>递归和循环的差别：循环可以复用栈帧，递归是每一层递归都要额外申请栈空间。循环实现递归的话相当于要手动维护一个”栈”数据结构来记录回头路，递归的话操作系统的进程栈%rsp自动完成了记录任务。现代编译器如gcc开启-O2有时能把递归变循环。</li></ol><h4 id="访问信息"><a href="#访问信息" class="headerlink" title="访问信息"></a>访问信息</h4><ol><li>立即数、寄存器、存储器（内存）</li><li>操作数：大多数指令有一个或多个操作数，指示出执行一个操作中要使用的源数据值，以及放置结果的目标位置。</li><li>将一个值从一个内存位置复制到另一个内存位置需要两条指令，指令1将原值加载到寄存器中，指令2将寄存器中的值写入目的位置。而立即数、寄存器、存储器三者之间只需要一条指令，寄存器到寄存器也只需要一条指令。</li></ol>]]></content>
    
    
    <categories>
      
      <category>CS基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机系统</tag>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CUDA 并行计算</title>
    <link href="/2026/02/15/hpc/cuda-parallel-computing/"/>
    <url>/2026/02/15/hpc/cuda-parallel-computing/</url>
    
    <content type="html"><![CDATA[<ol><li>学习书籍 <a href="https://fancyerii.github.io/2024/02/20/pmpp/">https://fancyerii.github.io/2024/02/20/pmpp/</a> 《大规模并行处理器编程实战》</li></ol>]]></content>
    
    
    <categories>
      
      <category>高性能计算</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CUDA</tag>
      
      <tag>并行计算</tag>
      
      <tag>GPU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenCL 指南</title>
    <link href="/2026/02/15/hpc/opencl-guide/"/>
    <url>/2026/02/15/hpc/opencl-guide/</url>
    
    <content type="html"><![CDATA[<h2 id="Opencl-指南"><a href="#Opencl-指南" class="headerlink" title="Opencl 指南"></a>Opencl 指南</h2><h3 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h3><p>​本文档以mali gpu为例记录本人使用opencl的相关要点。基于不同硬件如gpu、dsp等的编程涉及host端（cpu侧调用）、device端（kernel），主要流程大体上为，在host端分配内存、准备相关数据、通过接口向device传递数据，device端通过编写的kernel计算完后，host通过cpu去ddr上读取结果。</p><h3 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h3><p>​就目前接触而言，我认为有几个要点如下：</p><ol><li>共享内存：在cpu侧通过malloc分配的内存只能在cpu上访问，如果想分配能用dma的内存，通常需要调用底软封装的分配共享内存的接口。对于opencl而言，通过clCreateBuffer可以分配gpu能直接访问的内存，并返回cl_mem格式指针。如果cpu要访问或读写该内存，需要调用clEnqueueMapBuffer获得该ddr在cpu侧的虚拟地址，cpu在处理完后，需要调用clEnqueueUnmapMemObject指令，之后gpu才能继续访问并操作该内存。</li><li>异步提交：opencl的大部分指令都可以设置阻塞模式，即在调用该指令前，需要等之前的指令运行完，而异步提交则可通过cl_event类型的信号进行控制，api接口的最后两个参数分别为接受event、发送event。</li></ol><h3 id="主要步骤"><a href="#主要步骤" class="headerlink" title="主要步骤"></a>主要步骤</h3><ol><li><p>环境检查</p><p>clGetPlatformIDs<code>, </code>clGetDeviceIDs分别识别当前平台和设备，如Mali-G78AE GPU。</p></li><li><p>创建资源管理对象</p><p>​clCreateContext，clCreateCommandQueue。</p><p>​<strong>Context</strong> 是”<strong>静态资源管家</strong>“：负责管理内存、程序代码等<strong>空间</strong>上的资源。</p><p>​<strong>Queue</strong> 是”<strong>动态执行调度</strong>“：负责管理计算任务、数据搬运等<strong>时间</strong>上的流程。</p></li><li><p>编译内核程序</p><p>clCreateProgramWIthSource、clBuildProgram、clCreateKernel</p></li><li><p>输入输出内存分配管理</p><p>clCreateBuffer，一般来说为实现零copy，使用CL_MEM_ALLOC_HOST_PTR，该内存通过clEnqueueMapBuffer可以让cpu访问到。</p></li><li><p>数据读写</p><p>clEnqueueReadBuffer、clEnqueueWriteBuffer，是直接操作gpu内存指针cl_mem进行读写操作。</p></li><li><p>运行kernel</p><p>clEnqueueNDRangeKernel，该指令调用是异步的，可以通过cl_event传递任务是否完成，也可以调用clFinish来等待完成，也可以在调用clEnqueueReadBuffer时选择阻塞模式，即会等待clEnqueueNDRangeKernel指令完成。</p></li></ol><h3 id="指令相关选项"><a href="#指令相关选项" class="headerlink" title="指令相关选项"></a>指令相关选项</h3><pre><code class="hljs">1. context/deque 根据指令类型定1. 内存地址 cl_mem1. 阻塞模式：CL_TRUE1. 内存属性：是否支持读写等1. 内存起始位置1. 选择内存大小，bytesize1. event状态：发送event，接受event1. ...</code></pre>]]></content>
    
    
    <categories>
      
      <category>高性能计算</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并行计算</tag>
      
      <tag>GPU</tag>
      
      <tag>OpenCL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>llama.cpp 本地部署教程</title>
    <link href="/2026/02/15/llm-deploy/llama-cpp-deploy/"/>
    <url>/2026/02/15/llm-deploy/llama-cpp-deploy/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.youtube.com/watch?v=EPYsP-l6z2s">https://www.youtube.com/watch?v=EPYsP-l6z2s</a> 视频教程</p><h4 id="1-下载源码"><a href="#1-下载源码" class="headerlink" title="1. 下载源码"></a>1. 下载源码</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git <span class="hljs-built_in">clone</span> git@github.com:ggml-org/llama.cpp.git<br></code></pre></td></tr></table></figure><h4 id="2-编译"><a href="#2-编译" class="headerlink" title="2. 编译"></a>2. 编译</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#docs下有build.md编译文档</span><br><span class="hljs-comment">#cpu编译如下</span><br>cmake -B build<br>cmake --build build --config Release<br></code></pre></td></tr></table></figure><h3 id="3-准备模型"><a href="#3-准备模型" class="headerlink" title="3. 准备模型"></a>3. 准备模型</h3><pre><code class="hljs">从hugging face网站可以下载模型</code></pre><p><a href="https://huggingface.co/unsloth/gemma-3-4b-it-GGUF/blob/main/gemma-3-4b-it-Q4_0.gguf">https://huggingface.co/unsloth/gemma-3-4b-it-GGUF/blob/main/gemma-3-4b-it-Q4_0.gguf</a></p><h4 id="4-本地运行"><a href="#4-本地运行" class="headerlink" title="4. 本地运行"></a>4. 本地运行</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">build/bin/llama-cli -m custom-models/gemma-3-4b-it-Q4_0.gguf<br></code></pre></td></tr></table></figure><h4 id="5-本地服务运行"><a href="#5-本地服务运行" class="headerlink" title="5. 本地服务运行"></a>5. 本地服务运行</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">build/bin/llama-server -m custom-models/gemma-3-4b-it-Q4_0.gguf<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LLM部署</category>
      
    </categories>
    
    
    <tags>
      
      <tag>llama.cpp</tag>
      
      <tag>本地部署</tag>
      
      <tag>LLM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AD1000 Mali GPU 性能分析</title>
    <link href="/2026/02/15/performance/ad1000-gpu-analysis/"/>
    <url>/2026/02/15/performance/ad1000-gpu-analysis/</url>
    
    <content type="html"><![CDATA[<h2 id="AD1000-mali-GPU性能分析"><a href="#AD1000-mali-GPU性能分析" class="headerlink" title="AD1000 mali GPU性能分析"></a>AD1000 mali GPU性能分析</h2><h3 id="1-硬件信息查看"><a href="#1-硬件信息查看" class="headerlink" title="1. 硬件信息查看"></a>1. 硬件信息查看</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">./gpuperf -I<br></code></pre></td></tr></table></figure><p><img src="/./imgs/gpu_info.png" alt="gpu_info"></p><p>​表示该gpu是Valhall系列；product id：9005是Mali-G78AE的特定产品型号，专为智驾座舱设计；拥有4个shader cores；128位总线宽度表示GPU与L2 Cache及外部RAM之间数据通道宽度。以LPDDR5 3200MHz为例，带宽&#x3D;2x128x3200x1000x1000 &#x2F; (8x1024x1024x1024)&#x3D;95.3674GiB&#x2F;s，按10的3次方换算单位，带宽&#x3D;2x128x3.2 &#x2F; 8 &#x3D; 102.4GB&#x2F;s。</p><h3 id="2-GPU频率查看"><a href="#2-GPU频率查看" class="headerlink" title="2. GPU频率查看"></a>2. GPU频率查看</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">./gpuperf -i<br></code></pre></td></tr></table></figure><p><img src="/./imgs/gpu_freq.png" alt="gpu_freq"></p><p>​表示GPU当前的频率是800MHz，掩码0x33（0011 0011）表示在分布在核心槽位0，1，4，5上。</p><h3 id="3-GPU-preset-counter查看"><a href="#3-GPU-preset-counter查看" class="headerlink" title="3. GPU preset counter查看"></a>3. GPU preset counter查看</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">./gpuperf -a<br></code></pre></td></tr></table></figure><p><img src="/./imgs/gpu_preset_counter.png" alt="gpu_counter"></p><p>​表示gpu各组件的占用比、cycles数，每秒统计一次。fragment是片段着色单元，代表gpu涂色、光照、混合像素的忙碌程度；non-fragment非片段活跃周期及利用率。涵盖了顶点着色（Vertex）、几何计算和通用计算（Compute）；tiler的作用是将几何图形切分成像素格子的模块；Frag Overdraw 像素过度绘制率，代表平均每个像素点被重复涂色的次数，数值越高，说明浪费的带宽和算力越多。</p><h3 id="4-GPU-counter-查看"><a href="#4-GPU-counter-查看" class="headerlink" title="4. GPU counter 查看"></a>4. GPU counter 查看</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">./gpuperf -u<br></code></pre></td></tr></table></figure><p><img src="/./imgs/GPU_counter.png" alt="GPU_counter"></p><p>​GPU调度层面的指标，GPU Ac是GPU调度的Cycles；GPU Fragment：片段着色任务的活跃周期，统计像素渲染任务的排队执行时间；GPU Vertex-Tiling-Compute：非片段任务的调度周期；GPU vertex-Compute：纯粹的顶点处理与通用计算周期。</p><h3 id="5-GPU总线数据查看"><a href="#5-GPU总线数据查看" class="headerlink" title="5. GPU总线数据查看"></a>5. GPU总线数据查看</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">./gpuperf -m<br></code></pre></td></tr></table></figure><p><img src="/./imgs/gpu_ddr.png" alt="gpu_ddr"></p><p>​ExtBusRd&#x2F;ExtBusWr：外部总线读写的总字节数，直观显示了GPU此时对内存带宽的实时占用。ExtBusRdStall&#x2F;ExtBusWrStall：读写的停顿率，如果数值很高，说明 GPU 核心在”等数据”，由于 DDR 供货太慢，导致 GPU 只能空转。</p><h3 id="6-指标的详细解释"><a href="#6-指标的详细解释" class="headerlink" title="6. 指标的详细解释"></a>6. 指标的详细解释</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">./gpuperf -d a<br>./gpuperf -d u<br>./gpuperf -d m<br></code></pre></td></tr></table></figure><p><img src="/./imgs/gpu_counter_info.png" alt="gpu_counter_info"></p><p><img src="/./imgs/gpu_info.png" alt="gpu_info"></p><p><img src="/./imgs/ddr_info.png" alt="ddr_info"></p>]]></content>
    
    
    <categories>
      
      <category>性能优化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GPU</tag>
      
      <tag>Mali</tag>
      
      <tag>性能分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Arm Streaming 在域控的使用</title>
    <link href="/2026/02/15/performance/arm-streamline/"/>
    <url>/2026/02/15/performance/arm-streamline/</url>
    
    <content type="html"><![CDATA[<h2 id="Arm-Streaming在域控的使用（siengine-ad1000平台）"><a href="#Arm-Streaming在域控的使用（siengine-ad1000平台）" class="headerlink" title="Arm Streaming在域控的使用（siengine ad1000平台）"></a>Arm Streaming在域控的使用（siengine ad1000平台）</h2><h3 id="gatord监控进程编译"><a href="#gatord监控进程编译" class="headerlink" title="gatord监控进程编译"></a>gatord监控进程编译</h3><ol><li>源码下载</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git <span class="hljs-built_in">clone</span> https://github.com/ARM-software/gator.git<br></code></pre></td></tr></table></figure><ol start="2"><li>准备编译工具链</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#下载指定的编译工具链到本地</span><br>/data/toolchain/arm-gnu-toolchain-11.3.rel1-x86_64-aarch64-none-linux-gnu<br><span class="hljs-comment">#进入gatord，打开终端编译</span><br><span class="hljs-built_in">cd</span> gatord<br><span class="hljs-built_in">export</span> PATH=/data/toolchain/arm-gnu-toolchain-11.3.rel1-x86_64-aarch64-none-linux-gnu/bin:<span class="hljs-variable">$PATH</span><br>./build-linux.sh -p arm64-glibc<br><span class="hljs-comment">#编译过程中会出现报错</span><br>错误： <span class="hljs-string">&#x27;libgpuinfo&#x27;</span>未声明<br><br>  150 |     const auto gpuInfoInstance = libgpuinfo::instance::create();<br><span class="hljs-comment">#解决方法：这是命名空间的问题，应该是版本部匹配，将原命名空间(具体不记得了，debug一下能发现原因)改成libgpuinfo</span><br></code></pre></td></tr></table></figure><ol start="3"><li>产物打包送入域控</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#产物在build-arm64-glibc-rel路径下</span><br><span class="hljs-comment">#板子上直接运行./gatord即可</span><br></code></pre></td></tr></table></figure><h3 id="安装arm-streaming"><a href="#安装arm-streaming" class="headerlink" title="安装arm streaming"></a>安装arm streaming</h3><ol><li><p>下载 <a href="https://developer.arm.com/Tools%20and%20Software/Arm%20Performance%20Studio#Downloads">https://developer.arm.com/Tools%20and%20Software/Arm%20Performance%20Studio#Downloads</a></p></li><li><p>运行</p></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">./Streamline<br></code></pre></td></tr></table></figure><p>​相关操作可参考<a href="https://blog.csdn.net/JiMoKuangXiangQu/article/details/146945424">https://blog.csdn.net/JiMoKuangXiangQu/article/details/146945424</a></p>]]></content>
    
    
    <categories>
      
      <category>性能优化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>性能分析</tag>
      
      <tag>ARM</tag>
      
      <tag>Streamline</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图解大语言模型</title>
    <link href="/2026/02/15/llm/illustrated-llm/"/>
    <url>/2026/02/15/llm/illustrated-llm/</url>
    
    <content type="html"><![CDATA[<h3 id="一、大语言模型简介"><a href="#一、大语言模型简介" class="headerlink" title="一、大语言模型简介"></a>一、大语言模型简介</h3><ol><li>发展历史：<ol><li>词袋模型：相当于统计一句话中某个词（token）出现的次数，其数量在向量的指定维度表示。该模型忽略了语义特征与含义。</li><li>word2vec：用神经网络训练得到，具有语义信息，即具有相似语义的单词在向量表示上越靠近。</li><li></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>LLM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LLM</tag>
      
      <tag>大语言模型</tag>
      
      <tag>深度学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenCLAW 指令</title>
    <link href="/2026/02/15/tools/openclaw-commands/"/>
    <url>/2026/02/15/tools/openclaw-commands/</url>
    
    <content type="html"><![CDATA[<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">openclaw gateway restart <span class="hljs-comment">#重启服务</span><br>openclaw tui <span class="hljs-comment">#打开终端对话界面</span><br>openclaw onboard <span class="hljs-comment">#重新配置</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenCLAW</tag>
      
      <tag>指令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python 编程学习笔记</title>
    <link href="/2026/02/15/python/python-learning/"/>
    <url>/2026/02/15/python/python-learning/</url>
    
    <content type="html"><![CDATA[<h3 id="python编程从入门到实践"><a href="#python编程从入门到实践" class="headerlink" title="python编程从入门到实践"></a>python编程从入门到实践</h3><ol><li><p>python的数据类型主要分为：列表、元组、字典；</p><ol><li>列表：中括号构造，[‘math’, ‘English’, Chinese’]，可随意修改内部的成员。</li><li>元组：小括号构造，dimensions &#x3D; (50, 200)，无法通过访问成员去修改值，但可以通过重新构造的方式修改</li><li>字典：大括号构造，{‘color’ : ‘green’, ‘point’ : 5}，分为key和value。</li></ol></li><li><p>字符串中使用变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">first_name = <span class="hljs-string">&#x27;ada&#x27;</span><br>last_name = <span class="hljs-string">&#x27;lovelace&#x27;</span><br><span class="hljs-comment">#使用f字符来创建消息</span><br>full_name = <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;first_name&#125;</span> <span class="hljs-subst">&#123;last_name&#125;</span>&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>复制列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">my_foods = [<span class="hljs-string">&#x27;pizza&#x27;</span>, <span class="hljs-string">&#x27;falafel&#x27;</span>, <span class="hljs-string">&#x27;carrot cake&#x27;</span>]<br>friend_foods = my_foods[:]<br><span class="hljs-comment">#如果不用[:]，则类似于C++的引用</span><br>friend_foods = my_foods<br><span class="hljs-comment">#作为函数的形参同理</span><br></code></pre></td></tr></table></figure></li><li><p>sort排序</p><pre><code class="hljs">sort：永久排序，cars.sort();sorted：临时排序，cars.sorted();</code></pre></li><li><p>函数传递任意数量的实参</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#形参名*toppings中的星号让python创建一个名为toppings的空元组</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_pizza</span>(<span class="hljs-params">*topping</span>):<br>  <span class="hljs-string">&quot;&quot;&quot;打印顾客点的所有配料&quot;&quot;&quot;</span><br>  <span class="hljs-built_in">print</span>(toppings)<br><br>make_pizza(<span class="hljs-string">&#x27;pepperoni&#x27;</span>)<br>make_pizza(<span class="hljs-string">&#x27;mushrooms&#x27;</span>, <span class="hljs-string">&#x27;green peppers&#x27;</span>, <span class="hljs-string">&#x27;extra cheese&#x27;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-comment">#</span><br>def build_profile(<span class="hljs-keyword">first</span>, <span class="hljs-keyword">last</span>, **user_info)<br></code></pre></td></tr></table></figure></li><li><p>for循环、while循环、if语句、class类等格式</p><p>需要在末尾加上冒号:</p><p>for value in values:</p></li><li></li></ol>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>编程基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
